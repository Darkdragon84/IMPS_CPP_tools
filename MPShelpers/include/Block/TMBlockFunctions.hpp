#ifndef TM_BLOCK_FUNCTIONS
#define TM_BLOCK_FUNCTIONS

/**< Regular Transfer Matrix Operations ****************************************************************************************/

/**< Apply regular transfer matrix, generated by A, to the left onto unity (i.e. only \sum_s A_s' * A_s
 *   since there is no input matrix, the  output matrix is a BlockDiagMat */

/// returning version
template<typename KT,typename VT>
BlockDiagMat<KT,VT>
ApplyTMLeft(const MPSBlockMat<KT,VT>& A)
{
    BlockDiagMat<KT,VT> out;
    for (const auto& Ait : A) /// loop through phys. indices of A, Ait has type map of matrices, i.e. BlockMat !!
    {
        if (!Ait.empty()) /// see if there are any entries (i.e. symmetry sectors for current phys. index)
        {
            for (const auto& mapit : Ait) /// loop through symmetry sectors of current phys. index (mapit is of type QMatPair -> mapit.first = Qout, mapit.second = actual matrix)
            {
                auto outit = out.lower_bound(Qout(mapit)); /// look for current symmetry sector (result of A_s'*A_s has OUTgoing symmetry label of A_s)
                if (outit!=out.end() && outit->first==Qout(mapit)) outit->second += QMat(mapit).t() * QMat(mapit); /// if QN found, add result to already present contribution
                else out.emplace_hint(outit,Qout(mapit), QMat(mapit).t() * QMat(mapit) ); /// if QN not yet present, create and insert result
            }
        }
    }
    return out;
}


/// returning version
/// here we can allow a data type for out which is potentially different from VT and/or VTmat
template<typename KT,typename VT,typename VTmat>
BlockDiagMat<KT,typename promote_type<VT,VTmat>::result>
ApplyTMLeft(const MPSBlockMat<KT,VT>& A, const BlockDiagMat<KT,VTmat>& in)
{
    BlockDiagMat<KT,typename promote_type<VT,VTmat>::result> out;
    for (const auto& Ait : A)
    {
        if (!Ait.empty()) /// see if there are any symmetry sectors for current physical index s
        {
            for (const auto& matit : Ait) /// loop through symmetry sectors of A_s
            {
                const auto init = in.find(Qin(matit)); /// see if current INgoing symmetry sector is present in input matrix
                if (init!=in.end()) /// only do something if found
                {
                    auto outit = out.lower_bound(Qout(matit)); /// see if current OUTgoing symmetry sector already is present in output matrix
                    if (outit!=out.end() && outit->first==Qout(matit)) outit->second += QMat(matit).t() * ((init->second) * QMat(matit)); /// if QN found, add result to already present contribution
                    else out.emplace_hint(outit,Qout(matit),QMat(matit).t() * ((init->second) * QMat(matit)));/// if QN not yet present, create and insert result
                }
                else DOUT(Qin(matit)<<" not found"<<endl);
            }
        }
    }
    return out;
}


/**< This version is meant to be used in TMEigs only, where the memory of out is preallocated for speed */
/// VTmat should already be the top level promoted data type, i.e. the data type of the result of VT*VTmat
template<typename KT,typename VT,typename VTmat>
void
ApplyTMLeft(const MPSBlockMat<KT,VT>& A, const BlockDiagMat<KT,VTmat>& in, BlockDiagMat<KT,VTmat>& out)
{
    /**< ATTENTION: MAKE SURE OUT CONTAINS ALL NECESSARY SECTORS AND IS INITIALIZED TO ZERO */
    for (const auto& Ait : A)
    {
        if (!Ait.empty()) /// see if there are any symmetry sectors for current physical index s
        {
            for (const auto& matit : Ait) /// loop through symmetry sectors of A_s
            {
                const auto init = in.find(Qin(matit)); /// see if current INgoing symmetry sector is present in input matrix
                if (init!=in.end()) /// only do something if found
                {
                    auto outit = out.find(Qout(matit)); /// see if current OUTgoing symmetry sector already is present in output matrix
                    if (outit != out.end()) /// if QN found, add result to already present contribution
                        outit->second += QMat(matit).t() * ((init->second) * QMat(matit));
                    else /// we should not create any new sectors, they should already all be present in out
                        cerr<<"ApplyTMLeft(A,in,out): "<<Qout(matit)<<" not present"<<endl; /// should this throw??
                }
            }
        }
    }
}

/**< non-block diag versions ***********************************************************************************************************************************************/
/// returning version
template<typename KT,typename VT,typename VTmat>
inline
BlockMat<KT,typename promote_type<VT,VTmat>::result>
ApplyTMLeft(const MPSBlockMat<KT,VT>& A, const BlockMat<KT,VTmat>& in)
{
    return ApplyTMmixedLeft(in*A,A);
}

/**< This version is meant to be used in TMEigs only, where the memory of out is preallocated for speed */
/// VTmat should already be the top level promoted data type, i.e. the data type of the result of VT*VTmat
template<typename KT,typename VT,typename VTmat>
void
ApplyTMLeft(const MPSBlockMat<KT,VT>& A, const BlockMat<KT,VTmat>& in, BlockMat<KT,VTmat>& out)
{
    /**< ATTENTION: MAKE SURE OUT CONTAINS ALL NECESSARY SECTORS AND IS INITIALIZED TO ZERO */
    for (const auto& Ait : A)
    {
        if (!Ait.empty()) /// see if there are any symmetry sectors for current physical index s
        {
            for (const auto& init : in)
            {
                const auto lit = Ait.find(Qin(init));
                const auto rit = Ait.find(Qout(init));
                if (lit != Ait.end() && rit != Ait.end())
                {
                    auto outit = out.find(Qout(*lit));
                    if (outit != out.end())
                    {
                        assert(Qout(*outit) == Qout(*rit));
                        QMat(*outit) += QMat(*lit).t() * QMat(init) * QMat(*rit);
                    }
                    else /// we should not create any new sectors, they should already all be present in out
                        cerr<<"ApplyTMLeft(A,in,out): ("<<Qout(*lit)<<" not present"<<endl; /// should this throw?
                }
            }
        }
    }
}



/***************************************************************************************************************************************************************************/
/**< Apply regular transfer matrix, generated by A, to the right onto unity (i.e. only \sum_s A_s * A_s'
 *  since there is no input matrix, the  output matrix is a BlockDiagMat */
template<typename KT,typename VT>
BlockDiagMat<KT,VT>
ApplyTMRight(const MPSBlockMat<KT,VT>& A)
{
    BlockDiagMat<KT,VT> out;
    for (const auto& Ait : A) /// loop through phys. indices of A, Ait has type map of matrices, i.e. BlockMat !!
    {
        if (!Ait.empty()) /// see if there are any entries (i.e. symmetry sectors for current phys. index)
        {
            for (const auto& mapit : Ait) /// loop through symmetry sectors of current phys. index (matit is of type QMatPair)
            {
                auto outit = out.lower_bound(Qin(mapit)); /// look for current symmetry sector (result of A_s * A_s' has INgoing symmetry label of A_s)
                if (outit!=out.end() && outit->first==Qin(mapit)) outit->second += QMat(mapit) * QMat(mapit).t(); /// if QN found, add result to already present contribution
                else out.emplace_hint(outit,Qin(mapit), QMat(mapit) * QMat(mapit).t()); /// if QN not yet present, create and insert result
            }
        }
    }
    return out;
}


/// returning version
/// here we can allow a data type for out which is potentially different from VT and/or VTmat
template<typename KT,typename VT,typename VTmat>
BlockDiagMat<KT,typename promote_type<VT,VTmat>::result>
ApplyTMRight(const MPSBlockMat<KT,VT>& A, const BlockDiagMat<KT,VTmat>& in)
{
    BlockDiagMat<KT,typename promote_type<VT,VTmat>::result> out;
    for (const auto Ait : A)
    {
        if (!Ait.empty()) /// see if there are any symmetry sectors for current physical index s
        {
            for (const auto& matit : Ait) /// loop through symmetry sectors of A_s
            {
                const auto init = in.find(Qout(matit)); /// see if current OUTgoing symmetry sector is present in input matrix
                if (init!=in.end()) /// only do something if found
                {
                    auto outit = out.lower_bound(Qin(matit)); /// see if current INgoing symmetry sector already is present in output matrix
                    if (outit!=out.end() && outit->first==Qin(matit)) outit->second += (QMat(matit) * init->second) * QMat(matit).t(); /// if QN found, add result to already present contribution
                    else out.emplace_hint(outit,Qin(matit), (QMat(matit) * init->second) * QMat(matit).t() ); /// if QN not yet present, create and insert result
                }
            }
        }
    }
    return out;
}


/**< This version is meant to be used in TMEigs and InvertE only, where the memory of out is preallocated for speed */
/// VTmat should already be the top level promoted data type, i.e. the data type of the result of VT*VTmat
template<typename KT,typename VT,typename VTmat>
void
ApplyTMRight(const MPSBlockMat<KT,VT>& A, const BlockDiagMat<KT,VTmat>& in, BlockDiagMat<KT,VTmat>& out)
{
    /**< ATTENTION: MAKE SURE OUT CONTAINS ALL NECESSARY SECTORS AND IS INITIALIZED TO ZERO */
    for (const auto Ait : A)
    {
        if (!Ait.empty()) /// see if there are any symmetry sectors for current physical index s
        {
            for (const auto& matit : Ait) /// loop through symmetry sectors of A_s
            {
                const auto init = in.find(Qout(matit)); /// see if current OUTgoing symmetry sector is present in input matrix
                if (init!=in.end()) /// only do something if found
                {
                    auto outit = out.lower_bound(Qin(matit)); /// see if current INgoing symmetry sector already is present in output matrix
                    if (outit!=out.end() && outit->first==Qin(matit)) /// if QN found, add result to already present contribution
                        outit->second += (QMat(matit) * init->second) * QMat(matit).t();
                    else /// We should not create any new sectors, they should already BE in out!!
                        cerr<<"ApplyTMRight(A,in,out): "<<Qin(matit)<<" not present in out"<<endl; /// should this throw?
                }
            }
        }
    }
}


/**< non-block diag versions ***********************************************************************************************************************************************/
/// returning version
template<typename KT,typename VT,typename VTmat>
inline
BlockMat<KT,typename promote_type<VT,VTmat>::result>
ApplyTMRight(const MPSBlockMat<KT,VT>& A, const BlockMat<KT,VTmat>& in)
{
    return ApplyTMmixedRight(A*in,A);
}


/**< This version is meant to be used in TMEigs and InvertE only, where the memory of out is preallocated for speed */
/// make sure that a Mat<VT> and Mat<VTmat> are multipliable
/// VTmat should already be the top level promoted data type, i.e. the data type of the result of VT*VTmat
template<typename KT,typename VT,typename VTmat>
void
ApplyTMRight(const MPSBlockMat<KT,VT>& A, const BlockMat<KT,VTmat>& in, BlockMat<KT,VTmat>& out)
{
    /**< ATTENTION: MAKE SURE OUT CONTAINS ALL NECESSARY SECTORS AND IS INITIALIZED TO ZERO */
    for (const auto& Ait : A)
    {
        if (!Ait.empty()) /// see if there are any symmetry sectors for current physical index s
        {
            const KT dK(Ait.dK());
            for (const auto& init : in)
            {
                const auto lit = Ait.find(Qin(init)-dK);
                const auto rit = Ait.find(Qout(init)-dK);
                if (lit != Ait.end() && rit != Ait.end())
                {
                    auto outit = out.find(Qin(*lit));
                    if (outit != out.end())
                    {
                        assert(Qout(*outit) == Qin(*rit));
                        QMat(*outit) += QMat(*lit) * QMat(init) * QMat(*rit).t();
                    }
                    else /// we should not create any new sectors, they should already all be present in out
                        cerr<<"ApplyTMRight(A,in,out): ("<<Qin(*lit)<<" not present in out"<<endl;
                }
            }
        }
    }
}

/**********************************************************************************************************************************************************************/
/**< Left Mixed Transfer Matrix Operations ****************************************************************************************************************************/
/**********************************************************************************************************************************************************************/

///**< Apply mixed transfer matrix, generated by A (lower) and B (upper), to the left onto unity (i.e. only \sum_s B_s' * A_s) */
/// BlockDiagMat -> BlockDiagMat
/// ONLY USE THIS VERSION IF IT IS ABSOLUTELY SURE THAT A AND B HAVE THE SAME BLOCK STRUCTURE!!
template<typename KT,typename VTA, typename VTB>
BlockDiagMat<KT,typename promote_type<VTA,VTB>::result>
ApplyTMmixedLeftDiag(const MPSBlockMat<KT,VTA>& A, const MPSBlockMat<KT,VTB>& B)
{
    assert(A.size() == B.size()); /// check if A and B have same dimensions
    BlockDiagMat<KT,typename promote_type<VTA,VTB>::result> out;

/// TODO (valentin#2#2015-04-19): switch to iterators
    for (uint s=0; s<A.size(); ++s) /// loop through physical indices
    {
        if (!A[s].empty() && !B[s].empty()) /// check if both MPS matrices have entries for current phys. index
        {
            for (const auto Amatit : A[s]) /// for current i, loop through symmetry sectors of A_s (Amatit has type BlockMat)
            {
                const auto Bmatit = B[s].find(Qin(Amatit)); /// find corresponding symmetry sector in B_s (Bmatit has type ITERATOR of BlockMat)
                if (Bmatit!=B[s].end()) /// only do something if it is found in B_s
                {
                    /// look for current symmetry sector (result of B_s' * A_s has OUTgoing symmetry label of B_s as INgoing QN))
                    auto outit = out.lower_bound(Qout(*Bmatit));
                    if (outit!=out.end() && outit->first==Qout(*Bmatit))
                    {
                        assert(Qout(*Bmatit)==Qout(Amatit)); /// CHECK IF BLOCKDIAGMAT AS RESULT IS EVEN JUSTIFIED
                        outit->second += QMat(*Bmatit).t() * QMat(Amatit); /// if QN found, add result to already present contribution
                    }
                    else out.emplace_hint(outit,Qout(*Bmatit) , QMat(*Bmatit).t() * QMat(Amatit) ); /// if QN not yet present, create and insert result
                }
            }
        }
    }
    return out;
}

/// BlockDiagMat -> BlockDiagMat
/// ONLY USE THIS VERSION IF IT IS ABSOLUTELY SURE THAT A AND B HAVE THE SAME BLOCK STRUCTURE!!
template<typename KT,typename VTA,typename VTB,typename VTmat>
inline
BlockDiagMat<KT,typename promote_type<typename promote_type<VTA,VTmat>::result,VTB>::result>
//ApplyTMmixedLeftDiag(const MPSBlockMat<KT,VTA>& A, const MPSBlockMat<KT,VTB>& B, const BlockDiagMat<KT,VTmat>& in)
ApplyTMmixedLeft(const MPSBlockMat<KT,VTA>& A, const MPSBlockMat<KT,VTB>& B, const BlockDiagMat<KT,VTmat>& in)
{
//    in.ShowDims("in");
//    A.ShowDims("A");
//    B.ShowDims("B");
//    (in*A).ShowDims("in*A");
    return ApplyTMmixedLeftDiag(in*A,B);
}

/// general unity -> BlockMat
///**< Apply mixed transfer matrix, generated by A (lower) and B (upper), to the left onto unity (i.e. only \sum_s B_s' * A_s) */
template<typename KT,typename VTA, typename VTB>
BlockMat<KT,typename promote_type<VTA,VTB>::result>
ApplyTMmixedLeft(const MPSBlockMat<KT,VTA>& A, const MPSBlockMat<KT,VTB>& B)
{
    assert(A.size() == B.size()); /// check if A and B have same dimensions
    BlockMat<KT,typename promote_type<VTA,VTB>::result> out;
    for (uint s=0; s<A.size(); ++s) /// loop through physical indices
    {
        if (!A[s].empty() && !B[s].empty()) /// check if both MPS matrices have entries for current phys. index
        {
            for (const auto Amatit : A[s]) /// for current i, loop through symmetry sectors of A_s (Amatit has type BlockMat)
            {
                const auto Bmatit = B[s].find(Qin(Amatit)); /// find corresponding symmetry sector in B_s (Bmatit has type ITERATOR of BlockMat)
                if (Bmatit!=B[s].end()) /// only do something if it is found in B_s
                {
                    /// look for current symmetry sector (result of B_s' * A_s has OUTgoing symmetry label of B_s as INgoing QN and OUTgoing symmetry label of A_s as OUTgoing QN))
                    auto outit = out.lower_bound(Qout(*Bmatit));
                    if (outit!=out.end() && outit->first==Qout(*Bmatit) && outit->second.first == Qout(Amatit))
                        outit->second.second += QMat(*Bmatit).t() * QMat(Amatit); /// if QN found, add result to already present contribution
                    else out.emplace_hint(outit,Qout(*Bmatit) , std::make_pair(Qout(Amatit),QMat(*Bmatit).t() * QMat(Amatit)) ); /// if QN not yet present, create and insert result
                }
            }
        }
    }
    return out;
}

/// general BlockMat -> BlockMat
template<typename KT,typename VTA,typename VTB, typename VTmat>
inline
BlockMat<KT,typename promote_type<typename promote_type<VTA,VTmat>::result,VTB>::result>
ApplyTMmixedLeft(const MPSBlockMat<KT,VTA>& A, const MPSBlockMat<KT,VTB>& B, const BlockMat<KT,VTmat>& in)
{
    return ApplyTMmixedLeft(in*A,B);
}

/// BlockDiagMat -> general BlockMat (should rarely happen)
template<typename KT,typename VTA,typename VTB,typename VTmat>
inline
BlockMat<KT,typename promote_type<typename promote_type<VTA,VTmat>::result,VTB>::result>
ApplyTMmixedLeft_dK(const MPSBlockMat<KT,VTA>& A, const MPSBlockMat<KT,VTB>& B, const BlockDiagMat<KT,VTmat>& in)
{
    return ApplyTMmixedLeft(in*A,B);
}


/**< This version is meant to be used in TMEigs and InvertE only, where the memory of out is preallocated for speed */
/// VTI should already be the top level promoted data type, i.e. the data type of the result of VTA*VTB*VTI
template<typename KT,typename VTA,typename VTB, typename VTI>
void
ApplyTMmixedLeft(const MPSBlockMat<KT,VTA>& A,
                 const MPSBlockMat<KT,VTB>& B,
                 const BlockMat<KT,VTI>& in,
                 BlockMat<KT,VTI>& out)
{
    /**< ATTENTION: MAKE SURE OUT CONTAINS ALL NECESSARY SECTORS AND IS INITIALIZED TO ZERO */
    assert(A.size() == B.size() && "A and B need to be of same length");
    auto Ait = A.cbegin();
    auto Bit = B.cbegin();
    for ( ;Ait!=A.cend();++Ait,++Bit)
    {
        if (!Ait->empty() && !Bit->empty()) /// see if there are any symmetry sectors for current physical index s
        {
            for (const auto& init : in)
            {
                const auto lit = Bit->find(Qin(init));
                const auto rit = Ait->find(Qout(init));
                if (lit != Bit->end() && rit != Ait->end())
                {
                    auto outit = out.find(Qout(*lit));
                    if (outit != out.end())
                    {
                        assert(Qout(*outit) == Qout(*rit));
                        QMat(*outit) += QMat(*lit).t() * QMat(init) * QMat(*rit);
                    }
                    else /// we should not create any new sectors, they should already all be present in out
                        cerr<<"ApplyTMmixedLeft(A,in,out): ("<<Qout(*lit)<<" not present"<<endl; /// should this throw?

                }
            }
        }
    }
}



/***********************************************************************************************************************************************************************/
/**< Right Mixed Transfer Matrix Operations ****************************************************************************************************************************/
/***********************************************************************************************************************************************************************/

/**< Apply mixed transfer matrix, generated by A (lower) and B (upper), to the left onto unity (i.e. only \sum_s A_s * B_s') */
/// unity -> BlockDiagMat
/// ONLY USE THIS VERSION IF IT IS ABSOLUTELY SURE THAT A AND B HAVE THE SAME BLOCK STRUCTURE!!
template<typename KT,typename VTA,typename VTB>
BlockDiagMat<KT,typename promote_type<VTA,VTB>::result>
ApplyTMmixedRightDiag(const MPSBlockMat<KT,VTA>& A, const MPSBlockMat<KT,VTB>& B)
{
    assert(A.size() == B.size()); /// check if A and B have same dimensions
    BlockDiagMat<KT,typename promote_type<VTA,VTB>::result> out;

/// TODO (valentin#1#2015-04-19): switch to iterators
    for (uint s=0; s<A.size(); ++s) /// loop through physical indices
    {
        if (!A[s].empty() && !B[s].empty()) /// check if both MPS matrices have entries for current phys. index
        {
            for (const auto Amatit : A[s]) /// for current i, loop through symmetry sectors of A_s (Amatit has type BlockMat)
            {
                /// find corresponding symmetry sector in B_s (Bmatit has type ITERATOR of BlockMat),
                /// actually we should match Qout, but that's not possible. However we can exploit that if the two
                /// Qouts for the same s are equal, so are the Qins, so let's again look for these.
                const auto Bmatit = B[s].find(Qin(Amatit));
                if (Bmatit!=B[s].end()) /// only do something if it is found in B_s
                {
                    assert(Qout(*Bmatit) == Qout(Amatit) && "outgoing QN of A and B don't match.");
                    auto outit = out.lower_bound(Qin(Amatit)); /// look for current symmetry sector (result of B_s' * A_s has OUTgoing symmetry label of A_s)
                    if (outit!=out.end() && outit->first==Qin(Amatit)) outit->second += QMat(Amatit) * QMat(*Bmatit).t(); /// if QN found, add result to already present contribution
                    else out.emplace_hint(outit,Qin(Amatit) , QMat(Amatit) * QMat(*Bmatit).t()); /// if QN not yet present, create and insert result
                }
            }
        }
    }
    return out;
}

/// BlockDiagMat -> BlockDiagMat
/// ONLY USE THIS VERSION IF IT IS ABSOLUTELY SURE THAT A AND B HAVE THE SAME BLOCK STRUCTURE!!
template<typename KT,typename VTA,typename VTB, typename VTmat>
inline
BlockDiagMat<KT,typename promote_type<typename promote_type<VTA,VTmat>::result,VTB>::result>
//ApplyTMmixedRightDiag(const MPSBlockMat<KT,VTA>& A, const MPSBlockMat<KT,VTB>& B, const BlockDiagMat<KT,VTmat>& in)
ApplyTMmixedRight(const MPSBlockMat<KT,VTA>& A, const MPSBlockMat<KT,VTB>& B, const BlockDiagMat<KT,VTmat>& in)
{
    return ApplyTMmixedRightDiag(A*in,B);
}

/**< Apply mixed transfer matrix, generated by A (lower) and B (upper), to the left onto unity (i.e. only \sum_s A_s * B_s') */
/// general unity -> BlockMat
template<typename KT,typename VTA, typename VTB>
BlockMat<KT,typename promote_type<VTA,VTB>::result>
ApplyTMmixedRight(const MPSBlockMat<KT,VTA>& A, const MPSBlockMat<KT,VTB>& B)
{
    assert(A.size() == B.size()); /// check if A and B have same dimensions
    BlockMat<KT,typename promote_type<VTA,VTB>::result> out;
    for (uint s=0; s<A.size(); ++s) /// loop through physical indices
    {
        if (!A[s].empty() && !B[s].empty()) /// check if both MPS matrices have entries for current phys. index
        {
            const KT dKB(B[s].dK());
            for (const auto Amatit : A[s]) /// for current s, loop through symmetry sectors of A_s (Amatit has type BlockMat)
            {
                /// find corresponding symmetry sector in B_s (Bmatit has type ITERATOR of BlockMat),
                /// actually we should match Qout, but that's not possible. So unfortunately this time, we have to calculate Qin for B[s]
                /// from subtracting dKB (which is Qout(B[s]) - Qin(B[s])) for each s.
                const auto Bmatit = B[s].find(Qout(Amatit)-dKB);
                if (Bmatit!=B[s].end()) /// only do something if it is found in B_s
                {
                    auto outit = out.lower_bound(Qin(Amatit)); /// look for current symmetry sector (result of A_s * B_s' has INgoing symmetry label of A[s] as INgoing QN and INgoing symmetry label of B[s] as OUTgoing QN)
                    if (outit!=out.end() && outit->first==Qin(Amatit) && outit->second.first==Qin(*Bmatit))
                        outit->second.second += QMat(Amatit) * QMat(*Bmatit).t(); /// if QN found, add result to already present contribution
                    else out.emplace_hint(outit,Qin(Amatit) , std::make_pair(Qin(*Bmatit),QMat(Amatit) * QMat(*Bmatit).t()) ); /// if QN not yet present, create and insert result
                }
            }
        }
    }
    return out;
}

/// general BlockMat -> BlockMat
template<typename KT,typename VTA,typename VTB, typename VTmat>
inline
BlockMat<KT,typename promote_type<typename promote_type<VTA,VTmat>::result,VTB>::result>
ApplyTMmixedRight(const MPSBlockMat<KT,VTA>& A, const MPSBlockMat<KT,VTB>& B, const BlockMat<KT,VTmat>& in)
{
    return ApplyTMmixedRight(A*in,B);
}

/// BlockDiagMat -> BlockMat (should rarely happen)
template<typename KT,typename VTA,typename VTB,typename VTmat>
inline
BlockMat<KT,typename promote_type<typename promote_type<VTA,VTmat>::result,VTB>::result>
ApplyTMmixedRight_dK(const MPSBlockMat<KT,VTA>& A, const MPSBlockMat<KT,VTB>& B, const BlockDiagMat<KT,VTmat>& in)
{
    return ApplyTMmixedRight(A*in,B);
}

/**< This version is meant to be used in TMEigs and InvertE only, where the memory of out is preallocated for speed */
/// make sure that a Mat<VT> and Mat<VTmat> are multipliable
/// VTI should already be the top level promoted data type, i.e. the data type of the result of VTA*VTB*VTI
template<typename KT,typename VTA,typename VTB, typename VTI>
void
ApplyTMmixedRight(const MPSBlockMat<KT,VTA>& A,
                  const MPSBlockMat<KT,VTB>& B,
                  const BlockMat<KT,VTI>& in,
                  BlockMat<KT,VTI>& out)
{
    /**< ATTENTION: MAKE SURE OUT CONTAINS ALL NECESSARY SECTORS AND IS INITIALIZED TO ZERO */
    auto Ait = A.cbegin();
    auto Bit = B.cbegin();
    for (;Ait!=A.cend();++Ait,++Bit)
    {
        if (!Ait->empty() && !Bit->empty()) /// see if there are any symmetry sectors for current physical index s
        {
/// TODO (valentin#1#): actually, dKA and dKB should be the same, otherwise a fixed point wouldn't make sense?
            const KT dKA(Ait->dK());
            const KT dKB(Bit->dK());
            for (const auto& init : in)
            {
                const auto lit = Ait->find(Qin(init)-dKA);
                const auto rit = Bit->find(Qout(init)-dKB);
                if (lit != Ait->end() && rit != Bit->end())
                {
                    auto outit = out.find(Qin(*lit));
                    if (outit != out.end())
                    {
                        assert(Qout(*outit) == Qin(*rit));
                        QMat(*outit) += QMat(*lit) * QMat(init) * QMat(*rit).t();
                    }
                    else /// we should not create any new sectors, they should already all be present in out
                    {
                        cerr<<"ApplyTMmixedRight(A,in,out): ("<<Qin(*lit)<<" not present in out"<<endl; /// should this throw?
                    }
                }
            }
        }
    }
}


/***********************************************************************************************************************************************************************/
/**< chained applications of TM ****************************************************************************************************************************************/
/***********************************************************************************************************************************************************************/

/**< LEFT TM OPERATIONS ************************************************************************************************************************************************/
/// left returning version
template<typename KT, typename VT>
BlockDiagMat<KT,VT>
ApplyTMLeft(const MPSBlockMatArray<KT,VT>& Avec)
{
    auto Ait = Avec.cbegin();
    BlockDiagMat<KT,VT> out = ApplyTMLeft(*Ait++);
    while (Ait!=Avec.cend()) out = ApplyTMLeft(*Ait++,out);
    return out;
}


/// left returning version
/// in can be either BlockDiagMat or BlockMat. Since we have the regular TM, the result is of the same BlockMatType
template<typename KT,typename VT,typename TVM> /// TVM = type of virtual matrix, should be either BlockMat or BlockDiagMat
TVM
ApplyTMLeft(const MPSBlockMatArray<KT,VT>& Avec, const TVM& in)
{
    auto Ait = Avec.cbegin();
    TVM out = ApplyTMLeft(*Ait++,in);
    while (Ait!=Avec.cend()) out = ApplyTMLeft(*Ait++,out);
    return out;
}

/**< This version is meant to be used in TMEigs and InvertE only, where the memory of out is preallocated for speed */
/// left modifying version
template<typename KT,typename VT,typename TVM> /// TVM = type of virtual matrix, should be either BlockMat or BlockDiagMat
void
ApplyTMLeft(const MPSBlockMatArray<KT,VT>& Avec,
            const TVM& in,
            TVM& out)
{
    if (Avec.size()>1)
    {
        auto Ait = Avec.cbegin();
        auto Aend = Avec.cend()-1;
        TVM tmp = ApplyTMLeft(*Ait++,in);
        while (Ait!=Aend) tmp = ApplyTMLeft(*Ait++,tmp);
        ApplyTMLeft(*Ait,tmp,out);
    }
    else ApplyTMLeft(Avec.front(),in,out);
}

/**< RIGHT TM OPERATIONS ************************************************************************************************************************************************/
/// right returning version
template<typename KT,typename VT>
BlockDiagMat<KT,VT>
ApplyTMRight(const MPSBlockMatArray<KT,VT>& Avec)
{
    auto Ait = Avec.crbegin();
    BlockDiagMat<KT,VT> out = ApplyTMRight(*Ait++);
    while (Ait!=Avec.crend()) out = ApplyTMRight(*Ait++,out);
    return out;
}

/// right returning version
/// in can be either BlockDiagMat or BlockMat. Since we have the regular TM, the result is of the same BlockMatType
template<typename KT,typename VT,typename VTM> /// TVM = type of virtual matrix, should be either BlockMat or BlockDiagMat
VTM
ApplyTMRight(const MPSBlockMatArray<KT,VT>& Avec, const VTM& in)
{
    auto Ait = Avec.crbegin();
    VTM out = ApplyTMRight(*Ait++,in);
    while (Ait!=Avec.crend()) out = ApplyTMRight(*Ait++,out);
    return out;
}

/**< This version is meant to be used in TMEigs and InvertE only, where the memory of out is preallocated for speed */
/// right modifying version
template<typename KT,typename VT,typename TVM> /// TVM = type of virtual matrix, should be either BlockMat or BlockDiagMat
void
ApplyTMRight(const MPSBlockMatArray<KT,VT>& Avec,
             const TVM& in,
             TVM& out)
{
    if (Avec.size()>1)
    {
        auto Ait = Avec.crbegin();
        auto Aend = Avec.crend()-1;
        TVM tmp = ApplyTMRight(*Ait++,in);
        while (Ait!=Aend) tmp = ApplyTMRight(*Ait++,tmp);
        ApplyTMRight(*Ait,tmp,out);
    }
    else ApplyTMRight(Avec.back(),in,out);
}

/***********************************************************************************************************************************************************************/
/**< chained applications of mixed TM **********************************************************************************************************************************/
/***********************************************************************************************************************************************************************/

/**< LEFT MIXED TM OPERATIONS ******************************************************************************************************************************************/
/// left returning diagonal version without input
/// ONLY USE THIS VERSION IF IT IS ABSOLUTELY SURE THAT A AND B HAVE THE SAME BLOCK STRUCTURE!!
/// here it makes sense to determine the result type of a VTA*VTB multiplication, as we don't have an input
template<typename KT, typename VTA, typename VTB>
BlockDiagMat<KT,typename promote_type<VTA,VTB>::result>
ApplyTMmixedLeftDiag(const MPSBlockMatArray<KT,VTA>& Avec, const MPSBlockMatArray<KT,VTB>& Bvec)
{
    assert(Avec.size() == Bvec.size() && "A and B need to be of same size");
    auto Ait = Avec.cbegin();
    auto Bit = Bvec.cbegin();

    BlockDiagMat<KT,typename promote_type<VTA,VTB>::result> out = ApplyTMmixedLeftDiag(*Ait++,*Bit++);
    while (Ait != Avec.cend()) out = ApplyTMmixedLeftDiag(*Ait++,*Bit++,out);
    return out;
}

/// left returning diagonal version
/// ONLY USE THIS VERSION IF IT IS ABSOLUTELY SURE THAT A AND B HAVE THE SAME BLOCK STRUCTURE!!
/// VTI should already be the top level promoted data type, i.e. the data type of the result of VTA*VTB*VTI
template<typename KT, typename VTA, typename VTB, typename VTI>
BlockDiagMat<KT,VTI>
ApplyTMmixedLeft(const MPSBlockMatArray<KT,VTA>& Avec,
                     const MPSBlockMatArray<KT,VTB>& Bvec,
                     const BlockDiagMat<KT,VTI>& in)
//ApplyTMmixedLeftDiag(const MPSBlockMatArray<KT,VTA>& Avec,
//                     const MPSBlockMatArray<KT,VTB>& Bvec,
//                     const BlockDiagMat<KT,VTI>& in)
{
    assert(Avec.size() == Bvec.size() && "A and B need to be of same size");
    auto Ait = Avec.cbegin();
    auto Bit = Bvec.cbegin();

//    BlockDiagMat<KT,VTI> out = ApplyTMmixedLeftDiag(*Ait++,*Bit++,in);
//    while (Ait != Avec.cend()) out = ApplyTMmixedLeftDiag(*Ait++,*Bit++,out);
    BlockDiagMat<KT,VTI> out = ApplyTMmixedLeft(*Ait++,*Bit++,in);
//    out.ShowDims("first out in ArrayFun");
    while (Ait != Avec.cend()) out = ApplyTMmixedLeft(*Ait++,*Bit++,out);
    return out;
}


/// left returning version
/// general BlockMat -> BlockMat
/// VTI should already be the top level promoted data type, i.e. the data type of the result of VTA*VTB*VTI
template<typename KT,typename VTA, typename VTB, typename VTI>
BlockMat<KT,VTI>
ApplyTMmixedLeft(const MPSBlockMatArray<KT,VTA>& Avec, const MPSBlockMatArray<KT,VTB>& Bvec, const BlockMat<KT,VTI>& in)
{
    assert(Avec.size() == Bvec.size() && "A and B need to be of same size");
    auto Ait = Avec.cbegin();
    auto Bit = Bvec.cbegin();
    BlockMat<KT,VTI> out = ApplyTMmixedLeft(*Ait++,*Bit++,in);
    while (Ait!=Avec.cend()) out = ApplyTMmixedLeft(*Ait++,*Bit++,out);
    return out;
}


/**< This version is meant to be used in TMEigs and InvertE only, where the memory of out is preallocated for speed */
/// left modifying version
/// VTI should already be the top level promoted data type, i.e. the data type of the result of VTA*VTB*VTI
template<typename KT,typename VTA, typename VTB, typename VTI>
void
ApplyTMmixedLeft(const MPSBlockMatArray<KT,VTA>& Avec,
                 const MPSBlockMatArray<KT,VTB>& Bvec,
                 const BlockMat<KT,VTI>& in,
                 BlockMat<KT,VTI>& out)
{
    assert(Avec.size() == Bvec.size() && "A and B need to be of same size");
    if (Avec.size()>1)
    {
        auto Ait = Avec.cbegin();
        auto Bit = Bvec.cbegin();
        auto Aend = Avec.cend()-1;

        BlockMat<KT,VTI> tmp = ApplyTMmixedLeft(*Ait++,*Bit++,in);
        while (Ait!=Aend) tmp = ApplyTMmixedLeft(*Ait++,*Bit++,tmp);
        ApplyTMmixedLeft(*Ait,*Bit,tmp,out);
    }
    else ApplyTMmixedLeft(Avec.front(),Bvec.front(),in,out);
}

/**< LEFT MIXED TM OPERATIONS ******************************************************************************************************************************************/

/// right returning diag version
/// ONLY USE THIS VERSION IF IT IS ABSOLUTELY SURE THAT A AND B HAVE THE SAME BLOCK STRUCTURE!!
template<typename KT,typename VTA,typename VTB, typename VTI>
BlockDiagMat<KT,VTI>
ApplyTMmixedRightDiag(const MPSBlockMatArray<KT,VTA>& Avec,
                      const MPSBlockMatArray<KT,VTB>& Bvec)
{
    assert(Avec.size() == Bvec.size() && "A and B need to be of same size");
    auto Ait = Avec.crbegin();
    auto Bit = Bvec.crbegin();
    BlockDiagMat<KT,VTI> out = ApplyTMmixedRightDiag(*Ait++,*Bit++);
    while (Ait!=Avec.crend()) out = ApplyTMmixedRightDiag(*Ait++,*Bit++,out);
    return out;
}

/// right returning diag version
/// ONLY USE THIS VERSION IF IT IS ABSOLUTELY SURE THAT A AND B HAVE THE SAME BLOCK STRUCTURE!!
template<typename KT,typename VTA,typename VTB, typename VTI>
BlockDiagMat<KT,VTI>
ApplyTMmixedRight(const MPSBlockMatArray<KT,VTA>& Avec,
                      const MPSBlockMatArray<KT,VTB>& Bvec,
                      const BlockDiagMat<KT,VTI>& in)
//ApplyTMmixedRightDiag(const MPSBlockMatArray<KT,VTA>& Avec,
//                      const MPSBlockMatArray<KT,VTB>& Bvec,
//                      const BlockDiagMat<KT,VTI>& in)
{
    assert(Avec.size() == Bvec.size() && "A and B need to be of same size");
    auto Ait = Avec.crbegin();
    auto Bit = Bvec.crbegin();
//    BlockDiagMat<KT,VTI> out = ApplyTMmixedRightDiag(*Ait++,*Bit++,in);
//    while (Ait!=Avec.crend()) out = ApplyTMmixedRightDiag(*Ait++,*Bit++,out);
    BlockDiagMat<KT,VTI> out = ApplyTMmixedRight(*Ait++,*Bit++,in);
    while (Ait!=Avec.crend()) out = ApplyTMmixedRight(*Ait++,*Bit++,out);
    return out;
}

/// right returning version
/// VTI should already be the top level promoted data type, i.e. the data type of the result of VTA*VTB*VTI
template<typename KT,typename VTA,typename VTB, typename VTI>
BlockMat<KT,VTI>
ApplyTMmixedRight(const MPSBlockMatArray<KT,VTA>& Avec,
                  const MPSBlockMatArray<KT,VTB>& Bvec,
                  const BlockMat<KT,VTI>& in)
{
    assert(Avec.size() == Bvec.size() && "A and B need to be of same size");
    auto Ait = Avec.crbegin();
    auto Bit = Bvec.crbegin();
    BlockMat<KT,VTI> out = ApplyTMmixedRight(*Ait++,*Bit++,in);
    while (Ait!=Avec.crend()) out = ApplyTMmixedRight(*Ait++,*Bit++,out);
    return out;
}

/**< This version is meant to be used in TMEigs and InvertE only, where the memory of out is preallocated for speed */
/// right modifying version
/// VTI should already be the top level promoted data type, i.e. the data type of the result of VTA*VTB*VTI
template<typename KT,typename VTA,typename VTB,typename VTI>
void
ApplyTMmixedRight(const MPSBlockMatArray<KT,VTA>& Avec,
                  const MPSBlockMatArray<KT,VTB>& Bvec,
                  const BlockMat<KT,VTI>& in,
                  BlockMat<KT,VTI>& out)
{
    assert(Avec.size() == Bvec.size() && "A and B need to be of same size");
    if (Avec.size()>1)
    {
        auto Ait = Avec.crbegin();
        auto Bit = Bvec.crbegin();
        auto Aend = Avec.crend()-1;
        BlockMat<KT,VTI> tmp = ApplyTMmixedRight(*Ait++,*Bit++,in);
        while (Ait!=Aend) tmp = ApplyTMmixedRight(*Ait++,*Bit++,tmp);
        ApplyTMmixedRight(*Ait,*Bit,tmp,out);
    }
    else ApplyTMmixedRight(Avec.back(),Bvec.back(),in,out);
}

/***********************************************************************************************************************************************************************/
/**< Operator transfer matrices ****************************************************************************************************************************************/
/***********************************************************************************************************************************************************************/

/**< LEFT OPERATOR TM OPERATIONS ***************************************************************************************************************************************/

/// ONLY USE THIS VERSION IF IT IS ABSOLUTELY SURE THAT A AND O*A HAVE THE SAME BLOCK STRUCTURE, I.E. THAT O IS A SYMMETRIC OPERATOR!!
template<typename KT, typename VT, typename VTO>
inline
BlockDiagMat<KT,typename promote_type<VT,VTO>::result>
ApplyOpTMLeftDiag(const SparseOperator<VTO>& O, const MPSBlockMat<KT,VT>& A)
{
    return ApplyTMmixedLeftDiag(ApplyOperator(A,O),A);
}

/// ONLY USE THIS VERSION IF IT IS ABSOLUTELY SURE THAT A AND O*A HAVE THE SAME BLOCK STRUCTURE, I.E. THAT O IS A SYMMETRIC OPERATOR!!
template<typename KT, typename VT, typename VTO, typename VTmat>
inline
BlockDiagMat<KT,typename promote_type<typename promote_type<VT,VTmat>::result,VTO>::result>
ApplyOpTMLeftDiag(const SparseOperator<VTO>& O, const MPSBlockMat<KT,VT>& A, const BlockDiagMat<KT,VTmat>& mat)
{
    return ApplyTMmixedLeftDiag(ApplyOperator(mat*A,O),A);
}

template<typename KT, typename VT, typename VTO>
inline
BlockMat<KT,typename promote_type<VT,VTO>::result>
ApplyOpTMLeftGen(const SparseOperator<VTO>& O, const MPSBlockMat<KT,VT>& A)
{
    return ApplyTMmixedLeft(ApplyOperator(A,O),A);
}

template<typename KT, typename VTMPSA, typename VTMPSB, typename VTO>
inline
BlockMat<KT,typename promote_type<typename promote_type<VTMPSA,VTO>::result,VTMPSB>::result>
ApplyOpTMLeftGen(const SparseOperator<VTO>& O, const MPSBlockMat<KT,VTMPSA>& A, const MPSBlockMat<KT,VTMPSB>& B)
{
    return ApplyTMmixedLeft(ApplyOperator(A,O),B);
}

/**< LEFT OPERATOR TM OPERATIONS ***************************************************************************************************************************************/

/// ONLY USE THIS VERSION IF IT IS ABSOLUTELY SURE THAT A AND O*A HAVE THE SAME BLOCK STRUCTURE, I.E. THAT O IS A SYMMETRIC OPERATOR!!
template<typename KT, typename VT, typename VTO>
inline
BlockDiagMat<KT,typename promote_type<VT,VTO>::result>
ApplyOpTMRightDiag(const SparseOperator<VTO>& O, const MPSBlockMat<KT,VT>& A)
{
    return ApplyTMmixedRightDiag(ApplyOperator(A,O),A);
}

/// ONLY USE THIS VERSION IF IT IS ABSOLUTELY SURE THAT A AND O*A HAVE THE SAME BLOCK STRUCTURE, I.E. THAT O IS A SYMMETRIC OPERATOR!!
template<typename KT, typename VT, typename VTO, typename VTmat>
inline
BlockDiagMat<KT,typename promote_type<typename promote_type<VT,VTmat>::result,VTO>::result>
ApplyOpTMRightDiag(const SparseOperator<VTO>& O, const MPSBlockMat<KT,VT>& A, const BlockDiagMat<KT,VTmat>& mat)
{
    return ApplyTMmixedRightDiag(ApplyOperator(A*mat,O),A);
}

template<typename KT, typename VT, typename VTO>
inline
BlockMat<KT,typename promote_type<VT,VTO>::result>
ApplyOpTMRightGen(const SparseOperator<VTO>& O, const MPSBlockMat<KT,VT>& A)
{
    return ApplyTMmixedRight(ApplyOperator(A,O),A);
}

template<typename KT, typename VTMPSA, typename VTMPSB, typename VTO>
inline
BlockMat<KT,typename promote_type<typename promote_type<VTMPSA,VTO>::result,VTMPSB>::result>
ApplyOpTMRightGen(const SparseOperator<VTO>& O, const MPSBlockMat<KT,VTMPSA>& A, const MPSBlockMat<KT,VTMPSB>& B)
{
    return ApplyTMmixedRight(ApplyOperator(A,O),B);
}

#endif // TM_BLOCK_FUNCTIONS
